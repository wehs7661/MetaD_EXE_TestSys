import argparse 
import plumed
import itertools
import numpy as np
from tqdm.auto import tqdm

def initialize():
    parser = argparse.ArgumentParser(
        description="This codes calculate a free energy surface from a HILLS file."
    )
    parser.add_argument(
        "-hh",
        "--hills",
        default="HILLS_2D",
        help="The HILLS file generated by metadynamics."
    )
    parser.add_argument(
        "-t",
        "--temp",
        type=float,
        default=298.15,
        help="The simulation temperature used for converting energy units."
    )
    parser.add_argument(
        "-v",
        "--vars",
        nargs="+",
        default=["theta", "lambda"],
        help="The variable names logged in HILLS_2D."
    )
    parser.add_argument(
        "-g",
        "--grid_info",
        nargs="+",
        default=["-np.pi", "np.pi", "360", "0", "15", "16"],
        help="Grid information that contains min, max and the number of grids for each CV."
    )
    parser.add_argument(
        "-z",
        "--zero",
        default=False,
        action="store_true",
        help='Whether the zero the free energy profile or not.'
    )
    parser.add_argument(
        "-s",
        "--slice",
        nargs="+",
        help="Fixed values given for slicing the free energy surface." 
             "The dimension of the input should be the same as the number of CV,"
             "with the CV being projected denoted as 'np.nan'."
        )
    parser.add_argument(
        "-u",
        "--units",
        choices=["kT", "kJ/mol"],
        default="kJ/mol",
        help="Energy units (kT or kJ/mol)."
    )
     
    args_parse = parser.parse_args()

    return args_parse 

def gaussian(x, mu, sigma):
    """
    Calculate the Guassian at x given the mean and standard deviation of the Gaussian (h=1). 
    """
    return np.exp(-(x-mu) ** 2 / (2 * sigma ** 2))

def reorder_product(*a):
    """
    Reverse the output of itertools.product to make the order consistent with PLUMED fes.dat
    """
    for tup in itertools.product(*a[::-1]):
        yield tup[::-1]

if __name__ == "__main__":
    # 0. Read in the data and set things up
    args = initialize()
    n_CVs = len(args.vars)
    k = 1.38064852E-23  # Boltzmann constant
    N_A = 6.02214086E23 # Avogadro constant
    kT = (k * args.temp) * N_A / 1000   # divided by kT -> units: kT
    
    hills_data = plumed.read_as_pandas(args.hills)
    sigma_list, mu_list =[], []
    for i in range(n_CVs):
        sigma_list.append(hills_data["sigma_" + args.vars[i]])
        mu_list.append(hills_data[args.vars[i]])

    # 1. Get the grid points
    grid_info = [eval(i) for i in args.grid_info]   # for cases containing "np.pi"
    grid_min, grid_max, grid_nbins = [], [], []
    for i in range(len(args.grid_info)):
        if i % 3 == 0:
            grid_min.append(grid_info[i])
        elif i % 3 == 1:
            grid_max.append(grid_info[i])
        else:
            grid_nbins.append(grid_info[i])

    if args.slice is None:
        # Case 1: Get the grd points for the multidimensional free energy
        grids = []
        for i in range(n_CVs):
            grids.append(np.linspace(grid_min[i], grid_max[i], grid_nbins[i]))
        
        grid_points = list(reorder_product(*grids))  # a list of tuple of grid points
    else:
        # Case 2: Get the grid points for a slice of the free energy surface (1D output)
        args.slice = [eval(i) for i in args.slice]   
        idx = args.slice.index(np.nan)   # the index of the CV to be projected to
        grids = np.linspace(grid_min[idx], grid_max[idx], grid_nbins[idx])
        grid_points = []
        for i in range(len(grids)):
            grid_points.append(tuple([grids[i] if x is np.nan else x for x in args.slice]))

    # 2. Calculate the negative of free energy 
    f_profile = []
    for i in tqdm(range(len(grid_points))):
        f = 0   
        for j in range(len(hills_data["time"])):   # sum up all the multivariate Gaussians
            g_list = []
            for k in range(n_CVs):  # get the Gaussian for each dimnsion
                g_list.append(gaussian(grid_points[i][k], mu_list[k][j], sigma_list[k][j]))
            total_g = hills_data["height"][j] * np.product(g_list)   # multivariate gaussian
            f += total_g
        f_profile.append(f)

    # 3. Write fes.dat
    if args.slice is None:
        fes_file = open("fes.dat", "w")
    else:
        fes_file = open(f"fes_{args.vars[idx]}.dat", "w")
    fes_file.write(f"\t{'  '.join(args.vars)}  f\n")

    if args.units == "kT":
        f_profile = np.array(f_profile) / kT  
    if args.zero:
        f_profile = f_profile - np.min(f_profile)

    for i in range(len(grid_points)):
        grid_str = ''
        for j in range(n_CVs):
            grid_str += f"\t{grid_points[i][j]: .6f}"
        fes_file.write(f"{grid_str}\t{f_profile[i]:.6f}\n")
    
